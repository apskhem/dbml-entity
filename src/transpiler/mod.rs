use std::env;
use std::ffi::OsString;
use std::fs::File;
use std::io::{Write, Result, Error, ErrorKind};
use std::{path::Path, fs};

use crate::{NAME, VERSION};
use crate::analyzer::{*, self};
use crate::ast::*;
use crate::generator::{Codegen, TargetLang, Block};
use crate::parser::*;

use inflector::Inflector;

mod traits;
use traits::*;
mod err;
mod config;

#[derive(Debug, PartialEq, Clone)]
pub enum Target {
  SeaORM
}

#[derive(Debug, PartialEq, Clone)]
pub struct Config  {
  in_path: OsString,
  out_path: Option<OsString>,
  target: Target
}

impl Config {
  pub fn new(in_path: impl AsRef<Path>, target: Target) -> Self {
    Self {
      in_path: in_path.as_ref().into(),
      out_path: None,
      target
    }
  }

  pub fn set_out_path(mut self, path: impl AsRef<Path>) -> Self {
    self.out_path = Some(path.as_ref().into());

    self
  }

  pub fn transpile(&self) -> Result<()> {
    let raw_in = fs::read_to_string(&self.in_path)?;

    let out_ast = parse(&raw_in).unwrap_or_else(|e| panic!("{}", e));

    let sem_ast = out_ast.analyze();
    
    let result = transpile(sem_ast, &self.target).unwrap_or_else(|e| panic!("{}", e));

    let out_path = if let Some(out_path) = self.out_path.clone() {
      out_path
    } else {
      env::var_os("OUT_DIR")
        .ok_or_else(|| {
          Error::new(ErrorKind::Other, "OUT_DIR environment variable is not set")
        })?
    };

    File::create(out_path)?.write_all(result.as_bytes())?;

    Ok(())
  }
}

fn transpile(ast: analyzer::SematicSchemaBlock, target: &Target) -> Result<String> {
  match target {
    Target::SeaORM => transpile_sea_orm_postgresql(ast)
  }
}

fn transpile_sea_orm_postgresql(ast: analyzer::SematicSchemaBlock) -> Result<String> {
  let codegen = Codegen::new(TargetLang::Rust)
    .line(format!("//! Generated by {NAME} {VERSION}"))
    .line_skip(1)
    .line("use sea_orm::entity::prelude::*;");

  let codegen = ast.tables.into_iter().fold(codegen, |acc, table| {
    let table::TableBlock {
      ident: table::TableIdent {
        name,
        schema,
        ..
      },
      cols: fields,
      indexes,
      ..
    } = table;

    let table_block = Block::new(2, Some("pub struct Model"));
    let rel_block = Block::new(2, Some("pub enum Relation"));

    let table_block = fields.into_iter().fold(table_block,|acc, field| {
      let mut out_fields = vec![];

      if let Some(exp_type) = field.r#type.to_col_type(&field.args) {
        out_fields.push(format!(r#"column_type = "{}""#, exp_type))
      }
      if field.settings.is_pk {
        out_fields.push(format!("primary_key"))
      }
      if field.settings.is_nullable {
        out_fields.push(format!("nullable"))
      }

      let field_rust_type = field.r#type.to_rust_sea_orm_type();
      let field_string = if field.settings.is_nullable {
        format!("Option<{}>", field_rust_type)
      } else {
        field_rust_type
      };
      
      acc
        .line_cond(!out_fields.is_empty(), format!("#[sea_orm({})]", out_fields.join(", ")))
        .line(format!("pub {}: {},", field.name, field_string))
    });

    let mod_block = Block::new(1, Some(format!("pub mod {}", name)))
      .line("use sea_orm::entity::prelude::*;")
      .line_skip(1)
      .line(format!("#[derive(Clone, Debug, PartialEq, DeriveEntityModel)]"))
      .line(format!(r#"#[sea_orm(table_name = "{}", schema_name = "{}")]"#, name, schema.unwrap_or_else(|| "public".into())))
      .block(table_block)
      .line_skip(1)
      .line("#[derive(Copy, Clone, Debug, EnumIter, DeriveRelation)]")
      .block(rel_block)
      .line_skip(1)
      .line("impl ActiveModelBehavior for ActiveModel {}");

    acc
      .line_skip(1)
      .block(mod_block)
  });

  let codegen = ast.enums.into_iter().fold(codegen, |acc, r#enum| {
    let enums::EnumBlock {
      ident: enums::EnumIdent {
        name,
        schema,
        ..
      },
      values,
      ..
    } = r#enum;

    let enum_block = Block::new(1, Some(format!("pub enum {}", name.to_pascal_case())));

    let enum_block = values.into_iter().fold(enum_block,|acc, value| {
      let value_name = value.value.to_pascal_case();

      acc
        .line(format!(r#"#[sea_orm(string_value = "{}")]"#, value_name))
        .line(format!("{},", value_name))
    });

    acc
      .line_skip(1)
      .line("#[derive(Clone, Debug, PartialEq, EnumIter, DeriveActiveEnum)]")
      .line(
        format!(r#"#[sea_orm(rs_type = "String", db_type = "Enum", enum_name = "{}", schema_name = "{}")]"#, name, schema.unwrap_or("public".into()))
      )
      .block(enum_block)
  });

  Ok(codegen.to_string())
}
