use std::env;
use std::ffi::OsString;
use std::fs::File;
use std::io::{Write, Error, ErrorKind};
use std::{path::Path, fs};

use crate::ast::*;
use crate::generator::{Codegen, TargetLang, Block};
use crate::parser::*;

const NAME: &'static str = env!("CARGO_PKG_NAME");
const VERSION: &'static str = env!("CARGO_PKG_VERSION");

#[derive(Debug, PartialEq, Clone)]
pub enum Target {
  SeaORMPostgreSQL
}

#[derive(Debug, PartialEq, Clone)]
pub struct Config  {
  in_path: OsString,
  out_path: Option<OsString>,
  target: Target
}

impl Config {
  pub fn new(in_path: impl AsRef<Path>, target: Target) -> Self {
    
    Self {
      in_path: in_path.as_ref().into(),
      out_path: None,
      target
    }
  }

  pub fn set_out_path(mut self, path: impl AsRef<Path>) -> Self {
    self.out_path = Some(path.as_ref().into());

    self
  }

  pub fn transpile(&self) {
    let raw_in = fs::read_to_string(&self.in_path).expect("cannot read the input file");

    let out_ast = parse(&raw_in).expect("cannot parse the input file");

    let sem_ast = out_ast.into_semantic();
    
    let result = transpile(sem_ast, &self.target).expect("cannot transpile the input file");

    let out_path = self.out_path.clone().unwrap_or_else(|| {
      env::var_os("OUT_DIR")
        .ok_or_else(|| {
            Error::new(ErrorKind::Other, "OUT_DIR environment variable is not set")
        })
        .unwrap()
    });

    File::create(out_path)
      .expect("cannot create source module file")
      .write_all(result.as_bytes())
      .expect("error while writing to file");
  }
}

fn transpile(ast: schema::SematicSchemaBlock, target: &Target) -> Result<String, String> {
  match target {
    Target::SeaORMPostgreSQL => transpile_sea_orm_postgresql(ast)
  }
}

fn transpile_sea_orm_postgresql(ast: schema::SematicSchemaBlock) -> Result<String, String> {
  let codegen = Codegen::new(TargetLang::Rust);

  let codegen = codegen
    .line(format!("//! DBML Entity. Generated by {NAME} {VERSION}"))
    .line("");

  let codegen = ast.tables.into_iter().fold(codegen, |acc, table| {
    let mut table_block = Block::new(2, Some("pub struct Model"));
    let mut rel_block = Block::new(2, Some("pub enum Relation"));

    let table::TableBlock {
      ident: table::TableIdent {
        name,
        schema,
        ..
      },
      fields,
      indexes,
      ..
    } = table;

    fields.into_iter().for_each(|field| {
      let mut out_fields = vec![];

      if field.col_settings.is_pk {
        out_fields.push("primary_key")
      } else if field.col_settings.is_nullable {
        out_fields.push("nullable")
      }

      if !out_fields.is_empty() {
        table_block.line(format!("#[sea_orm({})]", out_fields.join(", ")));
      }
      
      table_block.line(format!("pub {}: {},", field.col_name, field.col_type.to_rust_type()));
    });

    let mut mod_block = Block::new(1, Some(format!("pub mod {}", name)));

    mod_block.line("use sea_orm::entity::prelude::*;");
    mod_block.line("");
    mod_block.line(format!("#[derive(Clone, Debug, PartialEq, DeriveEntityModel)]"));
    mod_block.line(format!("#[sea_orm(table_name = \"{}\")]", name));
    mod_block.block(table_block);
    mod_block.line("#[derive(Copy, Clone, Debug, EnumIter, DeriveRelation)]");
    mod_block.block(rel_block);
    mod_block.line("impl ActiveModelBehavior for ActiveModel {}");

    acc.block(mod_block)
  });

  Ok(codegen.to_string())
}
